import hashlib
import time
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

class Block:
    def __init__(self, index, previous_hash, timestamp, data, hash):
        self.index = index
        self.previous_hash = previous_hash
        self.timestamp = timestamp
        self.data = data
        self.hash = hash

class Blockchain:
    def __init__(self):
        self.chain = [self.create_genesis_block()]
        self.privkey = serialization.load_pem_private_key(
            b'...',
            password=None,
            backend=default_backend()
        )

    def create_genesis_block(self):
        return Block(0, "0", int(time.time()), "Genesis Block", self.calculate_hash(0, "0", int(time.time()), "Genesis Block"))

    def calculate_hash(self, index, previous_hash, timestamp, data):
        value = str(index) + str(previous_hash) + str(timestamp) + str(data)
        return hashlib.sha256(value.encode('utf-8')).hexdigest()

    def add_block(self, data):
        previous_block = self.chain[-1]
        new_block = Block(len(self.chain), previous_block.hash, int(time.time()), data, None)
        new_block.hash = self.calculate_hash(len(self.chain), previous_block.hash, int(time.time()), data)
        self.chain.append(new_block)

    def verify_chain(self):
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i - 1]

            if current_block.hash != self.calculate_hash(current_block.index, previous_block.hash, current_block.timestamp, current_block.data):
                return False

        return True

    def sign_data(self, data):
        signature = self.privkey.sign(
            data.encode(),
            padding.PSS(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return signature

    def verify_signature(self, data, signature):
        public_key = self.privkey.public_key()
        try:
            public_key.verify(
                signature,
                data.encode(),
                padding.PSS(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True
        except:
            return False

# Example usage
blockchain = Blockchain()

# Adding certificate to the blockchain with digital signature
certificate = "Certificate 1 Data"
signature = blockchain.sign_data(certificate.encode())
blockchain.add_block(certificate + ',' + str(signature))

# Verifying certificate in the blockchain
certificate_with_signature = "Certificate 1 Data,<signature>"
if blockchain.verify_signature(certificate_with_signature.split(',')[0].encode(), bytes(certificate_with_signature.split(',')[1])):
    print("Certificate is valid.")
else:
    print("Certificate is invalid.")

# Validate block
